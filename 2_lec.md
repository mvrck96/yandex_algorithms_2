# Лекция 2. Линейный поиск

Линейный поиск - перебор всех элементов последовательности

Сложность такого поиска О(n)

## Алгоритм для одного прохода

Задача 1

![image-20210917120409853](/home/maverick/.config/Typora/typora-user-images/image-20210917120409853.png)

![image-20210917120856565](pics/image-20210917120856565.png)

Задача 2 

![image-20210917120842401](pics/image-20210917120842401.png)

![image-20210917120939742](pics/image-20210917120939742.png)

Задача 3

Дана последовательность длиной Н, найти максимальное число

![image-20210917121411347](pics/image-20210917121411347.png)

Копирование объектов занимает время, правда в питоне это все равно О(1) потому что в нем все ссылка. Но в других языках, перемещается целый обьект. Поэтому можно оперировать только  индексами обьектов из последовательности. Хотя скорее всего такой подход будет дольше. Тогда получится так:

![image-20210917122123409](pics/image-20210917122123409.png)

Задача 4

![image-20210917122226316](pics/image-20210917122226316.png)

Вот тут надо понимать формулировку задачи. Потому что если в такой последовательности 3 2 1 3 убрать первую 3 то останется 2 1 3. И вторым максимумом будет тоже 3

 ![image-20210917122854662](pics/image-20210917122854662.png)

Задача 5

![image-20210917123001899](pics/image-20210917123001899.png)

![image-20210917123328008](pics/image-20210917123328008.png)

Более универсальный вариант это добавить влаг, который будет изначально False, а как только встретится первое число подходящее под условие он станет True. Если так не сделать, то при условии что надо найти нечетное число использовать -1 будет нельзя 

## Алгоритм двупроходный

Идея с двойным проходом последовательности в том, что это будет бсытрее чем пройти один раз и в моменте прохода что то запонимать

Задача 6

![image-20210917123600514](pics/image-20210917123600514.png)

![image-20210917123927629](pics/image-20210917123927629.png)

Долгое решение потому что используется сложение строк. В питоне строка неизменяемый тип данных, поэтому при сложении двух строк создается 3 строка. Это долго. Можно этого избежать путем добавления в список. Это будет занимать время О(1). Исправленный вариант:

![image-20210917124147251](pics/image-20210917124147251.png)

Задача 7

![image-20210917124452566](pics/image-20210917124452566.png)

Сначала не ясно как это решать. Надо брать кубики воды и двигать их направо или налево, если есть преграда, то кубики остаются. . . Можно взять и все столбики преобразовать в числа, описывающие их высоту. Таким образом, последовательность острова 3 1 4 3 5 1 1 3 1. И поставить условие, если вода попала между двумя более высокими столбиками земли, то она остается, если нет, выливается. Предварительно надо найти максимум острова.

![image-20210917125307850](pics/image-20210917125307850.png)

## Задача с собеса RLE

![image-20210917125534549](pics/image-20210917125534549.png)

Вроде задача сложная. Поэтому разобьем её на более простые и для начала попытаемся упрощать строки типа AABBBCA в ABCA. Запоминаем последний символ, есть список в который будет ответом. Если новый символ не равен последнему, то последний добавляем в ответ и обновляем на текущий. Вот так:

![image-20210917125935965](pics/image-20210917125935965.png)

Для RLE надо еще подсчитывать кол-во одинаковых символов. Это можно сделать тоже через смену последнего символа, запоминать позиции и через вычитание понять сколько было одинаковых

![image-20210917130519047](pics/image-20210917130519047.png)

- Написание continue и break это скорее плохая практика, не стоит их использовать, потому что сложно читать такой код
- 